#!/usr/bin/env python

r'''Replay route waypoints from a file.
'''


import rclpy
from rclpy.qos import DurabilityPolicy, HistoryPolicy, QoSProfile

# We need to do these imports in this specific way for the parsing of the nav_msgs.msg.Path message to work.
import builtin_interfaces.msg
import geometry_msgs.msg
import nav_msgs.msg
import std_msgs.msg

from tf2_ros import TransformException
from tf2_ros.buffer import Buffer
from tf2_ros.transform_listener import TransformListener

from copy import deepcopy
from sys import exit


class ReplayRoute(rclpy.node.Node):
    r'''Replay a route file.
    '''
    def __init__(self):
        r'''Create a new route replayer node.
        '''
        super().__init__('replay_route')
        self.declare_parameter('frequency', 20.0)
        self.declare_parameter('global_frame', 'map')
        self.declare_parameter('robot_base_frame', 'base_footprint')
        self.declare_parameter('path', 'route.pon')

        self.__global_frame = self.get_parameter('global_frame').value
        self.__robot_frame = self.get_parameter('robot_base_frame').value

        self.__buffer = Buffer()
        self.__listener = TransformListener(self.__buffer, self)

        # Parse a nav_msgs.msg.Path message from file.
        path = self.get_parameter('path').value
        self.__route = eval(''.join(line.strip() for line in open(path)))

        self.__pub_goal = self.create_publisher(geometry_msgs.msg.PoseStamped, '/goal_pose', 1)

        period = 1.0 / self.get_parameter('frequency').value
        self.__timer = self.create_timer(period, self.__callback)

    def __callback(self):
        r'''Timer callback.
        '''
        # TODO: Update this method to perform the following tasks:
        #
        # 1. Select the next pose in the route
        # 2. Publish it as a goal to the navigation stack
        # 3. Use the TF buffer to check whether the robot is nearing the current goal
        # 4. When the robot is close enough to the current goal, return to step (1)
        # 5. After the robot approaches the final goal, terminate the node.
        #
        # Remember that THIS METHOD CANNOT LOOP INDEFINITELY, so feel free to add new attributes
        # to this class as needed, to keep up information on the current status of the operation.
        # For example, you will probably need an attribute to record the index of the current
        # goal. You may also want to add new parameters, e.g. for the threshold distance to the
        # next goal.

        pose = deepcopy(self.__route.poses[-1])
        pose.header.stamp = self.get_clock().now().to_msg()

        self.get_logger().info(f'Publishing pose: {pose}')

        self.__pub_goal.publish(pose)

        # TODO: Instead of stopping the timer, end the process after reaching the end of the route.
        self.__timer.cancel()
        # exit()


def main():
    r'''Start the node.
    '''
    rclpy.init()

    node = ReplayRoute()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
